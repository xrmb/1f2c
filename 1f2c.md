# 1f2c: 1 Folder 2 Computers

A peer-to-peer tool for efficient folder synchronization between two computers.

## Overview

1f2c enables direct file transfer between two computers without intermediate servers. The sender shares a folder, generates a share code, and the receiver uses that code to sync the folder contents efficiently by only transferring missing or corrupted data.

## How It Works

### Sender (Computer 1)
1. Start app and prompt for username (stored locally)
2. Select "Sender" mode
3. Select folder to share (max 10,000 files) OR reuse cached manifest
4. App builds file index and calculates SHA-256 hashes (16MB blocks)
   - Rehashes only if file size or modified date changed
5. 8-character alphanumeric share code is generated and displayed
6. Wait for receiver connection (shows username, 60s timeout)
7. Approve or reject connection
8. Only one connection at a time (rejects others while waiting)

### Receiver (Computer 2)
1. Start app and prompt for username (stored locally)
2. Select "Receiver" mode
3. Enter 8-character share code from sender
   - Invalid code: Shows error, prompt to re-enter
4. Wait for sender to acknowledge connection (60s timeout)
   - If rejected or timeout: Return to share code entry
5. Select target folder for synchronized files
6. Fetches manifest from sender
7. Compares local files against manifest
8. Requests only missing/corrupted blocks
9. Verifies integrity using SHA-256 hashes

## Technical Details

### Architecture
- **Target Browser**: Chrome only (v1)
- **Signaling**: PeerJS (CDN hosted: `https://cdn.jsdelivr.net/npm/peerjs@latest/dist/peerjs.min.js`)
- **Transfer Protocol**: WebRTC DataChannels (peer-to-peer, encrypted by default)
- **Integrity Verification**: SHA-256 hashing per 16MB block
- **Block Size**: 16MB for hashing, sub-chunked for transfer (256KB chunks)
- **Processing**: Single-threaded, sequential transfers
- **WebRTC Buffer**: Default configuration

### File Manifest Format
```javascript
{
  version: 1,
  totalSize: 123456789, // bytes
  fileCount: 42,
  folders: [
    "relative\\path\\folder1",  // Normalized to backslash
    "relative\\path\\folder2"
  ],
  files: [
    {
      path: "relative\\path\\to\\file.txt",  // Normalized to backslash
      size: 12345,
      modified: 1703520000000, // Unix timestamp (ms)
      blocks: [
        { index: 0, hash: "sha256_base64..." }, // 16MB each
        { index: 1, hash: "sha256_base64..." }
      ]
    }
  ]
}
```

### Message Protocol
```javascript
// Connection & Authentication
{ type: "hello", username: "Alice" }
{ type: "acknowledge", accepted: true } // Sender approves/rejects
{ type: "acknowledge", accepted: false, reason: "rejected" }

// Manifest Exchange
{ type: "request_manifest" }
{ type: "manifest", data: { /* manifest object as JSON */ } }

// Block Transfer (16MB blocks split into 256KB chunks)
{ type: "request_block", file: "path\\file.txt", block: 5 }
{ type: "block_chunk", file: "path\\file.txt", block: 5, chunk: 0, total: 64, data: ArrayBuffer }
// ... chunks 1-63
{ type: "block_complete", file: "path\\file.txt", block: 5 }

// Progress & Control
{ type: "progress", bytesTransferred: 12345, totalBytes: 98765 }
{ type: "pause" }  // Pauses after current chunk completes
{ type: "resume" } // Resumes from next chunk
{ type: "cancel" }
{ type: "error", message: "..." }

// Hash Verification
{ type: "hash_mismatch", file: "path\\file.txt", block: 5 } // Triggers stop
```

### Transfer Logic
- **Receiver-driven**: Only receiver requests blocks
- **Sequential**: One block at a time (single-threaded)
- **Sub-chunking**: 16MB blocks split into 256KB chunks for WebRTC transfer
- **Incremental sync**: Only missing/corrupted blocks transferred
- **No resume on disconnect**: Transfer stops, receiver must restart from share code entry

### Share Code & Connection
- **Code Format**: 8 alphanumeric characters (e.g., `A3F9K2M7`)
- **Generated**: Randomly (62^8 = 218 trillion combinations)
- **Expiration**: Never expires
- **Single Use**: Each code connects one sender-receiver pair at a time
- **Connection Timeout**: 60 seconds for sender to acknowledge receiver
- **Queue Handling**: Sender sees only one connection request; rejects others while waiting

### Reconnection Support
- **Sender Cache**: 
  - Manifest stored in localStorage for several days
  - On app restart: Option to reuse cached manifest or select new folder
  - Rehashing: Only files with changed size or modified date are rehashed
  - Cancel during indexing: Returns to folder selection, can reuse previous manifest

- **Receiver Reconnect**: 
  - On disconnect/error: Returns to share code entry
  - Re-enters same code to reconnect
  - Must re-select target folder

### Pause/Resume Mechanics
- **Pause**: Completes current chunk transfer, then pauses
- **Resume**: Continues from next chunk
- **Timeout**: If paused/idle for 60+ seconds, connection drops â†’ receiver returns to share code entry
- **Both Sides**: Either sender or receiver can pause/resume

### Error Handling & Limits

**Pre-flight Checks:**
- Sender: Max 10,000 files in selected folder
- Receiver: No space check (assume sufficient space available)

**Stop Transfer On:**
- Hash verification fails
- File deleted on sender mid-transfer  
- Network interruption/connection drop
- User cancels
- Any unexpected error
- Connection timeout (60s during handshake, 60s if paused)

**After Error:**
- Both sides return to initial state
- Sender: Returns to folder selection (can reuse cached manifest)
- Receiver: Returns to share code entry

**User Notifications:**
- Error displayed on both sender and receiver
- Clear error messages for each failure case
- File date preservation failures shown as warnings (transfer continues)

### User Experience

**Initial Setup:**
- First-time users prompted for username (stored in localStorage)
- Username shown in connection requests

**Progress Indicators:**
- Indexing/hashing progress:
  - Files processed / total files
  - Current file being hashed
  - Progress percentage
- Transfer progress:
  - Current file being transferred
  - Bytes transferred / total bytes (with units: KB/MB/GB)
  - Transfer speed (MB/s)
  - Estimated time remaining
  - File count (completed / total)

**Controls:**
- Pause button (both sender and receiver)
- Resume button  
- Cancel button
- Connection status indicator (connected/paused/error)

**Share Code Display:**
- 8 alphanumeric characters (e.g., `A3F9K2M7`)
- Displayed large and copyable
- Shown until connection established or timeout

**File/Folder Handling:**
- Empty folders created on receiver
- File modified dates preserved (best effort, warnings on failure)
- File attributes/permissions not preserved
- Path separators normalized to backslash (`\`)
- UTF-8 encoding for all filenames
- Max path length: 260 characters (Windows limit)

## Implementation

### Web App/PWA
- **Technology**: HTML5 + JavaScript + PeerJS
- **File Access**: File System Access API (Chrome only)
- **Storage**: localStorage for cached manifests and username
- **Deployment**: Static hosting (GitHub Pages, Netlify, Vercel)
- **Install**: Optional PWA install

### Key Technical Decisions
- **Chunk Size**: 256KB (optimal for WebRTC DataChannels)
- **Manifest Format**: JSON string (no binary encoding)
- **Path Normalization**: All paths use backslash (`\`)
- **Character Encoding**: UTF-8 for all strings
- **No i18n**: English only for v1
- **No Testing Requirements**: Manual testing in Chrome sufficient

## Assumptions & Constraints

1. Files will not be modified during transfer
2. Maximum 10,000 files per transfer
3. Single sequential transfer (no parallelization)
4. No transfer resume after disconnection (must restart from share code)
5. Sender must remain online during entire transfer
6. Chrome browser required (Edge may work but not officially supported)
7. Sufficient disk space assumed on receiver
8. File attributes/permissions not preserved
9. Single connection per share code at a time

## Future Enhancements (Out of Scope v1)

- Resume capability after disconnection
- Parallel block transfers
- Bandwidth throttling  
- File change detection during transfer
- Multi-receiver support
- Transfer history/logs
- File/folder exclusion patterns
- Cross-browser support (Firefox, Safari)
- Disk space verification
- File attribute preservation
- Internationalization (i18n)
- Connection quality monitoring
